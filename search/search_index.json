{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PolyShell","text":"<p>A high-performance coverage-preserving polygon reduction library for Python, written in Rust.</p> <p> </p> <p>Time to reduce a 50,000 point polygon by 90%.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>\u2705 Guarantees encapsulation of the initial polygon.</li> <li>\ud83d\udd25 Rust-powered performance.</li> <li>\ud83e\udde9 A simple Python API to access all reduction methods and modes.</li> <li>\ud83c\udf0d Seamlessly integration with NumPy and Shapely.</li> <li>\ud83d\udccf Tunable accuracy and reduction rates.</li> <li>\ud83d\udc0d Python and PyPy compatible.</li> </ul> <p>PolyShell is supported by the ECMWF through the Code for Earth programme.</p>"},{"location":"#installation","title":"Installation","text":"<p>PolyShell is available on PyPI for easy installation:</p> pip install polyshellSuccessfully installed polyshell <p>PolyShell can also be built from source using maturin. See the guide here.</p>"},{"location":"#example","title":"Example","text":"<p>All of PolyShell's reduction algorithms are accessible through <code>reduce_polygon</code>.</p> Python 3.10+ <pre><code>from polyshell import reduce_polygon\n\noriginal = [\n    (0.0, 0.0),\n    (0.0, 1.0),\n    (0.5, 0.5),\n    (1.0, 1.0),\n    (1.0, 0.0),\n    (0.0, 0.0),\n]\n\nreduced = reduce_polygon(original, \"auto\", method=\"vw\")\n</code></pre> <p>For all the available options, see the full list of features.</p>"},{"location":"#learn-more","title":"Learn more","text":"<p>For more information see the guide.</p>"},{"location":"reference/algorithms/charshape/","title":"Charshape","text":""},{"location":"reference/algorithms/ramer-douglas-peucker/","title":"Ramer-Douglas-Peucker","text":""},{"location":"reference/algorithms/visvalingam-whyatt/","title":"Visvalingam-Whyatt","text":"<p>The Visvalingam-Whyatt reduction method provided by PolyShell consists of a few modifications to the original line reduction algorithm by Visvalingam and Whyatt<sup>1</sup> in order to guarantee PolyShell's axioms.</p>"},{"location":"reference/algorithms/visvalingam-whyatt/#visvalingam-whyatt-algorithm","title":"Visvalingam-Whyatt Algorithm","text":"<p>In the original algorithm, vertices are assigned scores as measures of a point's importance, based upon the triangle formed by a vertex with its two neighbours. In the original algorithm this score is taken to be area displacement (AD), defined as the unsigned area of the associated triangle. Modifications to Visvalingam's algorithm by other scoring metrics have also been investigated<sup>2</sup>, leading to Visvalingam coining the term \"effective area\" (EA) to describe the score of a vertex more generally. Such examples include the introduction of the factor \\(EA = AD (1 - \\cos{\\theta})\\) used by Mapshaper to provide additional smoothing<sup>3</sup>. The algorithm then proceeds by removing vertices in order of their score, from lowest to highest, until the score of a vertex exceeds some threshold.</p>"},{"location":"reference/algorithms/visvalingam-whyatt/#modifications","title":"Modifications","text":"<p>To apply the Visvalingam-Whyatt algorithm to the problem of polygon reduction, it is necessary to correct for possible self-intersections which may occur. These issues tend to occur most frequently in channel-like geometries, like the example given below. One fairly common solution is to check that removal of a vertex will not lead to a self-intersection, otherwise it is skipped. Naive implementations can prove costly, however this can be somewhat improved by first querying an R-tree to reduce the number of likely culprits.</p> <p>TODO: Img with caption explanation</p> <p>Once the algorithm has been extended to the reduction of polygons, ensuring coverage is a relatively simple process. When assigning scores, if removal of a vertex would lead to a loss in coverage, the effective area is said to be infinite, otherwise it is set according to any valid metric. Thus, at each iteration, vertices removed are guaranteed to increase the area of the reduced polygon and hence ensure coverage at each step.</p>"},{"location":"reference/algorithms/visvalingam-whyatt/#implementation-notes","title":"Implementation Notes","text":"<p>The formulation of PolyShell's axioms provides the opportunity for some additional performance improvements beyond those possible when using the standard Visvalingam-Whyatt algorithm. In this section we will describe all the adjustments made beyond a typical implementation of the Visvalingam-Whyatt algorithm. We will also provide some justification as to why these reductions are valid and some expectations on the resulting uplift in performance.</p>"},{"location":"reference/algorithms/visvalingam-whyatt/#pre-processing","title":"Pre-processing","text":"<p>Immediately obvious is that the minimal reduction of any polygon is it's convex hull. For most purposes this is a poor reduction, losing almost all detail in the original shape. The convex hull does however identify which vertices are invariant under reduction. This feature allows us to segment the polygon into isolated sections, each of which can be reduced independently of the others, allowing for parallel reduction on a single polygon. For this purpose we use Melkman's algorithm, to compute the convex hull in linear time<sup>4</sup>.</p>"},{"location":"reference/algorithms/visvalingam-whyatt/#r-tree-adjustments","title":"R-tree Adjustments","text":"<p>Adaptations of Visvalingam-Whyatt for polygon reduction require use of an R-tree to prevent self-intersections. For typical reduction algorithms, this requires edges to be removed from the tree and new edges inserted at each iteration. In PolyShell's implementation, both of these steps are skipped while retaining correctness. Deletion is no longer necessary, as our reduction only expands outwards. Hence, edges which are removed can never cause self-intersections. Similarly, no new edges need to be added, as if a reduction causes an intersection with a new edge, then it would have already caused an intersection with one of the original edges. We have found that while a larger tree must be queried at every iteration, the savings by not rebalancing the tree outweigh any potential cost.</p> <ol> <li> <p>M. Visvalingam, J. D. Whyatt, 2013. Line generalisation by repeated elimination of points. \u21a9</p> </li> <li> <p>M. Visvalingam, 2016. The Visvalingam Algorithm: Metrics, Measures and Heuristics. \u21a9</p> </li> <li> <p>M. Bloch, 2014. Some weighting functions for Visvalingam simplification. \u21a9</p> </li> <li> <p>A. Melkman, 1987. On-line construction of the convex hull of a simple polyline. \u21a9</p> </li> </ol>"},{"location":"user-guide/axioms/","title":"PolyShell's Axioms","text":"<p>PolyShell promises to provide reliable high-performance polygon reduction algorithms which behave in a predictable way. PolyShell's axioms consist of both the assumptions we make about a user's input and, given these are upheld, the assumptions the user can make about the output they receive.</p>"},{"location":"user-guide/axioms/#polygon-validity","title":"Polygon Validity","text":"<p>All input to PolyShell is expected to be valid.</p> <p>Definition</p> <p>A polygon is said to be valid if:</p> <ol> <li>It consists of either zero or at least three unique points.</li> <li>It is closed.</li> <li>There are no duplicate points or self-intersections.</li> <li>The vertices are stored as a sequence in clockwise order.</li> </ol> <p>Whether a polygon abides to these requirements can be checked using the provided <code>is_valid</code> function.</p> <p>Tip</p> <p>When using validated functions, PolyShell with automatically correct for incorrect ordering. This point is only relevant for users who wish to use the unchecked algorithms.</p>"},{"location":"user-guide/axioms/#our-promise","title":"Our Promise","text":"<p>Provided the assumptions made above are upheld, PolyShell makes the following promises:</p> <ol> <li>The reduced polygon will always be valid.</li> <li>The reduced polygon will always contain the input polygon in its interior.</li> <li>Vertices are never moved nor added.</li> <li>Reduction preserves the ordering of the vertices, up to shifts and reversal.</li> </ol>"},{"location":"user-guide/features/","title":"Features","text":"<p>PolyShell currently provides three reduction algorithms to fit your needs. Each varies in their performance and reduction characteristics.</p> Algorithm Available modes Parallelism Fastest for Characteristics Visvalingam-Whyatt epsilon, length <sup>1</sup> Small reductions Smoothes boundary roughness, minimises area gain Ramer-Douglas-Peucher epsilon Large reductions Retains sharp concavities Charshape epsilon, length Large reductions Minimises edge length <p>Tip</p> <p>Whenever possible PolyShell will reduce a single polygon across multiple cores. This is handled automatically and can lead to a sizable uplift in performance.</p>"},{"location":"user-guide/features/#algorithms","title":"Algorithms","text":"<p>Note</p> <p>If no reduction method is specified, PolyShell will default to Visvalingam-Whyatt.</p>"},{"location":"user-guide/features/#visvalingam-whyatt","title":"Visvalingam-Whyatt","text":"<p>The Visvalingam-Whyatt algorithm iteratively removed vertices based on the area of the triangle formed with its two neighbours. At each iteration a vertex is removed only if the area of the polygon increases and that its topology is preserved.</p> <p>For more information on the algorithm see the reference.</p>"},{"location":"user-guide/features/#ramer-douglas-peucker","title":"Ramer-Douglas-Peucker","text":"<p>The Ramer-Douglas-Peucker algorithm recursively splits the polygon into segments. At each step of the recursion, a chord is drawn between endpoints of the current segment, and the segment is split at furthest visible point from this chord. Once this distance becomes small, the segment is reduced to a single chord.</p> <p>For more information on the algorithm see the reference.</p>"},{"location":"user-guide/features/#charshape","title":"Charshape","text":"<p>The Charshape algorithm iteratively adds vertices to minimise the maximum edge length. It begins by computing the constrained Delaunay triangulation, starting with the convex hull, iteratively adding edges.</p> <p>For more information on the algorithm see the reference.</p>"},{"location":"user-guide/features/#running-modes","title":"Running Modes","text":""},{"location":"user-guide/features/#epsilon","title":"Epsilon","text":"<p>Reduces a polygon to a set resolution.</p> <p>The precise meaning of epsilon varies depending on the particular algorithm, but broadly related to the resolution of a polygon.</p> <p>It is always the case that a smaller value of epsilon will lead to a more detailed approximation, at the expense of a greater number of vertices.</p> Algorithm Units Definition Visvalingam-Whyatt Area The minimum area of the smallest triangle formed by a triple of connected vertices Ramer-Douglas-Peucher Length The maximum distance between a string of vertices and the chord which connects the first and final points Charshape Length The maximum line segment length along the boundary, provided a string of shorter segments exists <p>Epsilon reduction mode can be enabled for supported algorithms using the <code>reduction_mode</code> argument, providing tolerance in the third position or using the keyword argument <code>epsilon</code>:</p> Python 3.10+ <pre><code>from polyshell import reduce_polygon\n\noriginal = [\n    (0.0, 0.0),\n    (0.0, 1.0),\n    (0.5, 0.5),\n    (1.0, 1.0),\n    (1.0, 0.0),\n    (0.0, 0.0),\n]\n\nreduced = reduce_polygon(original, \"epsilon\", epsilon=0.1, method=\"vw\")\n</code></pre>"},{"location":"user-guide/features/#length","title":"Length","text":"<p>Reduces a polygon to a target length.</p> <p>Depending on reduction direction the length is interpreted as a minimum or maximum. Provided the target length is between the size of the original polygon and the convex hull, the target is guaranteed to be obtained.</p> <p>Length reduction mode can be enabled for supported algorithms using the <code>reduction_mode</code> argument, providing the desired length in the third position or using the keyword argument <code>length</code>:</p> Python 3.10+ <pre><code>from polyshell import reduce_polygon\n\noriginal = [\n    (0.0, 0.0),\n    (0.0, 1.0),\n    (0.5, 0.5),\n    (1.0, 1.0),\n    (1.0, 0.0),\n    (0.0, 0.0),\n]\n\n# Length is the size of the coordinate vector, not the number of unique points\nreduced = reduce_polygon(original, \"length\", length=5, method=\"charshape\")\nassert len(reduced) == 5\n</code></pre>"},{"location":"user-guide/features/#external-package-support","title":"External Package Support","text":"<p>PolyShell currently supports polygons stored using Shapely's Polygon class and also as a NumPy ndarray of coordinate pairs. In each case, the reduced polygon will be returned as a list of coordinate pairs.</p> <ol> <li> <p>Parallelism is currently only supported by the epsilon reduction mode.\u00a0\u21a9</p> </li> </ol>"},{"location":"user-guide/getting-help/","title":"Getting help","text":"<p>PolyShell is still in early stages of development, and so it is possible that you may encounter rough edges or bugs. If you do encounter any problems, please open an issue on the GitHub repository. Likewise, any suggestions of features or contributions of your own are gladly accepted.</p>"},{"location":"user-guide/installation/","title":"Installation","text":""},{"location":"user-guide/installation/#download-from-pypi","title":"Download from PyPI","text":"<p>PolyShell binaries are published on PyPI and are available for all major platforms.</p> <p>Install PolyShell using your package manager of choice:</p> pipuv <p>pip install polyshell</p> <p>uv add polyshell</p>"},{"location":"user-guide/installation/#build-from-source","title":"Build from source","text":"<p>To build PolyShell from source both a functioning Rust compiler and maturin must be installed.</p>"},{"location":"user-guide/installation/#maturin","title":"maturin","text":"<p>PolyShell is built natively using the maturin build system.</p> <p>For development, PolyShell can be installed in editable mode to an activated virtual environment using the <code>maturin develop</code> command.</p> # Clone the PolyShell sourcegit clone https://github.com/ECMWFCode4Earth/PolyShell.gitcd PolyShell# Create and activate a virtual environmentpython -m venvsource venv/bin/activate# Install into the virtual environmentmaturin develop <p>Tip</p> <p>To build a binary wheel with optimization enabled run: <pre><code>maturin build --release\n</code></pre></p>"},{"location":"user-guide/installation/#uv","title":"uv","text":"<p>While builds can be managed directly with maturin, we recommended to instead use the interface provided by uv.</p> <p>As PolyShell is managed as project through uv, development hooks have been configured to the build process to the build process as seamless as possible.</p> # Clone the PolyShell sourcegit clone https://github.com/ECMWFCode4Earth/PolyShell.gitcd PolyShell# Sync packages with uvuv sync <p>uv automatically detects changes to the source and recompiles when necessary.</p> <p>Tip</p> <p>By default uv will build PolyShell with optimisations enabled. To disable optimizations uncomment the following line in the <code>pyproject.toml</code> file:</p> <pre><code>[tool.uv]\n# Rebuild package when any rust files change\ncache-keys = [{ file = \"pyproject.toml\" }, { file = \"rust/Cargo.toml\" }, { file = \"**/*.rs\" }]\n# Uncomment to build rust code in development mode\nconfig-settings = { build-args = '--profile=dev' }  # &lt;- Uncomment this line!\n</code></pre>"}]}